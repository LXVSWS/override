after decompilation, we see a secret_backdoor function that grant a shell, we want to call it

we see the program initializing a buffer of 140 bytes on the stack
then in the set_username, it takes an input and copy 41 bytes to the previous buffer + 140, this is a buffer overflow
the set_msg function use the value at buffer + 180 (value we control) to know how much data will be copied with strncpy
because of that, we can increase the length of how much bytes will be copied in strncpy and induce an exploit
we'll have to put a character with a high ascii value at the 41th byte in set_username input

PIE enabled makes an executable position-independent, meaning it can be loaded at any memory address
but without ASLR, the OS always loads the executable at the same base address every time
so the address of the secret_backdoor function will not change if we found it during execution :
r < <(python -c 'print "\xff" * 41 + "\n" + "A" * 222') then "p secret_backdoor" to get the address we need
our pattern generator tell us that we erase rbp at 192 bytes, it's a 64 bit program so the offset will be at 200 bytes

(python -c 'print "\xff" * 41 + "\n" + "A" * 200 + "\x8c\x48\x55\x55\x55\x55\x00\x00"' ; cat) | ./level09
