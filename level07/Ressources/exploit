this is a program that allow us to read and write on stack memory by writing the index of a buffer and the value to put at it
when reading the source code we saw that we cannot input an index that is a multiple of 3 or whose division by 16777216 gives 183
despite that, we could input any index, even out of bounds of the 400 bytes buffer that the program reserved on the stack

we know that the buffer allow 400 bytes but when we put indexes above this limit we found some interesting data
through experimentation, we found some data that, converted in hexadecimal, are addresses of the program instructions
they are at indexes 107, 109, 110, when we modify them, nothing change in the behavior of the program (no segmentation faults)
we also found interesting data at index 114 but the program block us because its a multiple of 3

to be allowed to put 114 we will use an int overflow, lets add 115 to the int max (2147483647) so we get 2147483762
when we use the number 2147483762, its converted to 115 and because indexes starts from zero we are accessing the index 114
this time, when we modify the value, the program end with a segmentation fault, that mean we probably found EIP
we cannot use environment variables to help us because the program disable them, so we will use a ret2libc exploit

system address is 0xf7e6aed0 (p system into gdb)
libc start address is 0xf7e2c000 (info proc map into gdb)
"/bin/sh" offset is 15d7ec (strings -a -t x /lib32/libc-2.15.so | grep "/bin/sh")
"/bin/sh" address is 0xf7f897ec (0xf7e2c000 + 15d7ec)

we change the value at the index 114 by the address of system converted to decimal : 4159090384
the index 115 is for the return address of system so its not mandatory
finally, the index 116 is for the parameter, so we put the address of "/bin/sh" converted to decimal : 4160264172

the final exploit is : store 4159090384 2147483762 store 4160264172 116 quit
